# Code for paper "Small Data Reliability Analysis: A Mixture Weibull Model and Applications"
This is a Python implementation of the Mixture Weibull model and its related experiments proposed by our paper, titled "Small Data Reliability Analysis: A Mixture Weibull Model and Applications".

## Concrete.py
This code defines two auxiliary functions: `inter` and `smote`, which are used to generate synthetic data.

The function `inter` takes a list `y` and an integer `m` as input. If the length of `y` is 1, it returns `y` as it is. Otherwise, it randomly selects a position `pos` in `y`, generates `m` random numbers, and adds new values to the list `y` based on the selected position and the neighboring values. Finally, it sorts the updated `y` list and returns it along with the original length of `y`.

The function `smote` takes a list `y` and an integer `m` as input. It first reshapes `y` into a column vector. Then, it applies the AgglomerativeClustering algorithm with `m` clusters to `y` and assigns each data point to a cluster. It creates `m` empty lists to store the data points belonging to each cluster. It then iterates over each data point and appends it to the corresponding cluster list. Next, it calculates the length of the first cluster list. If the length of `y` is less than 10, it applies the `inter` function to each cluster list twice. After that, it merges all the cluster lists into the first list, sorts it, and returns it along with the length.

The function `CCircularBlockBootstrap` takes a list `y`, its length `length`, and an integer `reps` as input. It initializes an empty list `alldata` to store the resampled data. It converts `y` into a numpy array and performs circular block bootstrap resampling using the `CircularBlockBootstrap` function from the `arch.bootstrap` module. It iterates over each resampled data and appends the resampled values to the `alldata` list after sorting them. Finally, it returns the `alldata` list.

The functions `partial_function` and `partial_derivative` are used to calculate partial derivatives. `partial_function` takes a function `f___`, an input matrix `input`, a position `pos`, a value `value`, a list `y`, and an integer `depth` as input. It temporarily replaces the value at the specified position in `input` with the given value, calls the function `f___` with the modified input, and returns the result. `partial_derivative` takes a function `f`, an input matrix `input`, a list `y`, and an integer `depth` as input. It initializes an empty array `ret` to store the partial derivatives. It iterates over each element in `input`, defines a lambda function `fg` that calls `partial_function` with the corresponding position fixed and the other values varying, and uses the `nd.Derivative` function from the `numdifftools` module to calculate the derivative of `fg` with respect to the fixed position. The calculated derivative is stored in the `ret` array. Finally, it returns the `ret` array.

The function `LL` calculates the log-likelihood function. It takes four parameters `k0`, `k1`, `k2`, a list `y`, and an integer `depth` as input. It initializes variables `V` (set to a constant value), `L` (initialized as 0), and performs a loop over each element in `y`. It calculates two components `com1` and `com2` based on the given formulas, and updates `L` by adding the logarithm of the weighted sum of the components. Finally, it returns the calculated `L`.

The function `NT` implements the Newton's method for optimization. It takes an input matrix
